# Association-Rule-Learning-Recommender
Suggesting products to users at the purchasing stage

"""association_rule

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xMXAKRuPuj0J6uDuBHJOUcxzDrJOW9-Z
"""

!pip install mlxtend
import pandas as pd
pd.set_option("display.max_columns", None)
pd.set_option("display.max_rows", None)
pd.set_option("display.width",500)
pd.set_option("display.expand_frame_repr",False)  # çıktının tek bir satırda olmasını sağlar.
from mlxtend.frequent_patterns import apriori, association_rules

df_ = pd.read_excel("/content/drive/MyDrive/online_retail_II (3).xlsx", sheet_name="Year 2010-2011")

df = df_.copy()

df.shape

###############################
########### TASK 1 ###########
###############################

# user 1 ürün ıd: 21987
# user 2 ürün ıd: 23235
# user 3 ürün ıd: 22747

# bu sepet bilgilerine göre en uygun ürün önerisini yapınız. (ürün önerileri 1 ya da 1 den fazla olabilir)
# Make the most appropriate product recommendation according to this basket information. (product recommendations can be 1 or more than 1)


# 2010-2011 Germany müşterilerine göre yapınız.
# Make according to 2010-2011 Germany customers.

df.shape

def outlier_thresholds(dataframe, variable):
    quartile1 = dataframe[variable].quantile(0.01)
    quartile3 = dataframe[variable].quantile(0.99)
    interquantile_range = quartile3 - quartile1
    up_limit = quartile3 + 1.5 * interquantile_range
    low_limit = quartile1 - 1.5 * interquantile_range
    return low_limit, up_limit

def replace_with_thresholds(dataframe, variable):
    low_limit, up_limit = outlier_thresholds(dataframe, variable)
    dataframe.loc[(dataframe[variable] < low_limit), variable] = low_limit
    dataframe.loc[(dataframe[variable] > up_limit), variable] = up_limit
    
def retail_data_prep(dataframe):
    dataframe.dropna(inplace=True)
    dataframe = dataframe[~dataframe["Invoice"].str.contains("C", na=False)]
    dataframe = dataframe[dataframe["Quantity"] > 0]
    dataframe = dataframe[dataframe["Price"] > 0]
    replace_with_thresholds(dataframe, "Quantity")
    replace_with_thresholds(dataframe, "Price")
    return dataframe

df = retail_data_prep(df)

df.shape

df_gr = df[df["Country"] == "Germany"]

df_gr.shape

############################################
# ARL Veri Yapısını Hazırlama (Invoice-Product Matrix) (Preparing the ARL Data Structure)
############################################

df_gr.head()

df_gr.groupby(["Invoice","Description"]).agg({"Quantity": "sum"}).head()

# bu tabloyu pivot_table çevirelim (let's convert this table to pivot_table)

df_gr.groupby(["Invoice","Description"]).agg({"Quantity": "sum"}).unstack().head()

# na'leri 0 ve 0'dan büyükleri 1 yapalım (Let's make na's 0 and 0's greater than 1)

df_gr.groupby(["Invoice","Description"]). \
agg({"Quantity": "sum"}). \
unstack(). \
fillna(0). \
applymap(lambda x: 1 if x > 0 else 0)

df_gr.groupby(["Invoice","StockCode"]). \
agg({"Quantity": "sum"}). \
unstack(). \
fillna(0). \
applymap(lambda x: 1 if x > 0 else 0).head()

# ürün sepeti oluşturan fonksiyonu yazalım (Let's write the function that creates the product basket)

def create_inv_pro(dataframe, id=False):
    if id:
        return dataframe.groupby(['Invoice', "StockCode"])['Quantity'].sum().unstack().fillna(0). \
            applymap(lambda x: 1 if x > 0 else 0)
    else:
        return dataframe.groupby(['Invoice', 'Description'])['Quantity'].sum().unstack().fillna(0). \
            applymap(lambda x: 1 if x > 0 else 0)

gr_inv_pro_df = create_inv_pro(df_gr,id=True)

gr_inv_pro_df.shape

# user 1 ürün id(product id): 21987
# user 2 ürün id(product id): 23235
# user 3 ürün id(product id): 22747

# Yukarıdaki sepet bilgilerine göre en uygun ürün önerisini yapınız. (ürün önerileri 1 ya da 1 den fazla olabilir)
# Make the most appropriate product suggestion according to the basket information above. (product recommendations can be 1 or more than 1)

# ürün kodunun hangi ürüne ait olduğunu bulmak için aşağıdaki fonksiyon kullanılır.
# The following function is used to find which product the product code belongs to.

def check_ıd(dataframe, stock_code):
  product_name = dataframe[dataframe["StockCode"] == stock_code][["Description"]].values[0].tolist()
  print(product_name)

# İstenen ürünlerin ne olduğuna check_ıd fonksiyonuyla bakalım.
# Let's look at what the desired products are with the check_id function.

check_ıd(df,21987)
check_ıd(df,23235)
check_ıd(df,22747)

###############################
########### TASK 2 ###########
###############################

############################################
# Birliktelik Kurallarının Çıkarılması (Removal of Association Rules)
############################################

# İlk olarak tüm olası ürün birlikteliklerin olasıklarını bulalım. Bunun için apriori fonksiyonu kullanılır
# First, let's find the probabilities of all possible product associations. For this, the apriori function is used.

frequents_itemsets = apriori(gr_inv_pro_df,min_support=0.01,use_colnames=True)

frequents_itemsets.sort_values("support",ascending=False).head(10)



rules = association_rules(frequents_itemsets,metric="support",min_threshold=0.01)

rules.sort_values(by="support",ascending=False).head()

rules.sort_values(by="lift",ascending=False).head()

###############################
########### TASK 3 ###########
###############################

# user 1 ürün id(product id): 21987
# user 2 ürün id(product id): 23235
# user 3 ürün id(product id): 22747

# Yukarıdaki ıdlerin hangi ürüne ati olduğunu bulalım.
# Let's find out which product the above ids belong to.

def check_ıd(dataframe,stock_code):
  product_name = dataframe[dataframe["StockCode"] == stock_code][["Description"]].values[0].tolist()
  print(product_name)

check_ıd(df,21987)
check_ıd(df,23235)
check_ıd(df,22747)

###############################
########### TASK 4 ###########
###############################

# User 1'e ürün önerisi (Product recommendation to User 1)
# ürün id (product id): 21987

product_id = 21987

# ilk önce lift'e göre sıralayalım (Let's sort by lift first)

sorted_rules = rules.sort_values("lift",ascending=False)

sorted_rules.head()

# boş bir tavsiye listesi oluşturalım (Let's create an empty recommendation list)

recommendation_list1 = []

for i, product in enumerate(sorted_rules["antecedents"]):
    for j in list(product):
        if j == product_id:
            recommendation_list1.append(list(sorted_rules.iloc[i]["consequents"])[0])

recommendation_list1[0:2]

# user 2 ürün id(product id): 23235

recommendation_list2 = []

product_id2 = 23235

for i, product in enumerate(sorted_rules["antecedents"]):
  for j in list(product):
    if j == product_id2:
      recommendation_list2.append(list(sorted_rules.iloc[i]["consequents"])[0])

recommendation_list2[0:2]

# user 3 ürün id(product id): 22747

recommendation_list3 = []

product_id3 = 22747

for i, product in enumerate(sorted_rules["antecedents"]):
  for j in list(product):
    if j == product_id3:
      recommendation_list3.append(list(sorted_rules.iloc[i]["consequents"])[0])

recommendation_list3[0:2]

###############################
########### GÖREV 4 ###########
###############################

# önerilen ürün isimleri nedir? (What are the suggested product names?)
# user 1 ürün id(product id): 21987
# user 2 ürün id(product id): 23235
# user 3 ürün id(product id): 22747

check_ıd(df,21988)

check_ıd(df,23244)

check_ıd(df,22746)
